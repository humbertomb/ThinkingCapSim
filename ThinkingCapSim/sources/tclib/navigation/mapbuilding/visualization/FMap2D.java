/* * (c) 1999-2000 Humberto Martinez * (c) 2003 Humberto Martinez */ package tclib.navigation.mapbuilding.visualization;import java.awt.*;import tc.vrobot.*;import tc.gui.visualization.*;import tclib.navigation.mapbuilding.*;import tclib.navigation.mapbuilding.lpo.*;import tclib.utils.fusion.*;import devices.pos.*;import wucore.widgets.*;import wucore.utils.geom.*;import wucore.utils.math.*;public class FMap2D extends World2D{				public static final double			ARROW_ANG		= 15.0 * Angles.DTOR;		public static final double			ARROW_SIZ		= 0.0;	public static final double			RADIUS			= 0.015;	public static final double			AFACTOR			= 1.7;		public static final int				H_LOCAL			= 0;	public static final int				H_GLOBAL		= 1;	public static final int				H_ODOM			= 2;	public static final int				H_COR			= 3;	/* Constructors */	public FMap2D (Model2D model, RobotDesc rdesc, FusionDesc fdesc) 	{    	this.initialise (model, rdesc, fdesc, null);    	this.initialise ();	}  	public FMap2D (Model2D model, RobotDesc rdesc, FusionDesc fdesc, String mapname) 	{    	this.initialise (model, rdesc, fdesc, mapname);    	this.initialise ();	}  	/* Instance methods */	protected void initialise () 	{		// Add support for HUD objects//    	model.hud_n				= 4;//    	model.hud_x[H_LOCAL]	= 45;//    	model.hud_y[H_LOCAL]	= 45;//    	model.hud_x[H_GLOBAL]	= 45;//    	model.hud_y[H_GLOBAL]	= 60;//    	model.hud_x[H_ODOM]		= 250;//    	model.hud_y[H_ODOM]		= 45;//    	model.hud_x[H_COR]		= 250;//    	model.hud_y[H_COR]		= 60;	}  	public void update (FSegMap fmap, Paths paths, Position pos)	{		int				i, j, cells;		double			xi, yi, xf, yf;		double			xu, yu, au;		double			dr0, dr1;				Line2[]			icon;		LPOFSegments	local;		LPOFSegments	global;		boolean[][]		grid;		double[][]		uncert;//		Position		dpos	= null;				if (fmap == null) return;				// Initialise component's model		model.clearView ();		// Initialise auxiliary constants		local	= fmap.local ().segs ();		global	= fmap.global ().segs ();		grid	= fmap.global ().grid ();		icon	= rdesc.icon;		uncert	= pos.uncert ();				        		// Set HUD data values//		model.hud_label[H_LOCAL]	= "Local:  " + local.numseg () + " segs";//		model.hud_label[H_GLOBAL]	= "Global: " + global.numseg () + " segs";		//		if ((paths != null) && ((dpos = paths.correction ()) != null))//			model.hud_label[H_COR]	= "Corr: [" + ((int) Math.round (dpos.x () * 1000.0)) + ", " + ((int) Math.round (dpos.y () * 1000.0)) + ", " + ((int) Math.round (dpos.alpha ()*Angles.RTOD)) + "] mm, deg";//		else//			model.hud_label[H_COR]	= "Corr: N/A";				// Draw explored cells		if (grid != null)		{			cells = fmap.global ().grid_n ();			for (i = 0; i < 2 * cells; i++)				for (j = 0; j < 2 * cells; j++)					if (grid[i][j])						model.addRawBox ((i - cells) - 0.5, (j - cells) - 0.5, (i - cells) + 0.5, (j - cells) + 0.5, Model2D.FILLED, Color.LIGHT_GRAY);		}					// Draw real map (a priori known map)		drawWorld ();		// Draw fuzzy segments (global map)		if (global != null)			for (i = 0; i < global.numseg (); i++)			{				xi	= global.segment (i).xi ();				yi	= global.segment (i).yi ();				xf	= global.segment (i).xf ();				yf	= global.segment (i).yf ();				dr0	= global.segment (i).v0_rho ();				dr1	= global.segment (i).v1_rho ();								model.addRawRotSegment (xi, yi, xf, yf, dr1, 0.0, Color.CYAN);						model.addRawRotSegment (xi, yi, xf, yf, dr0, 0.0, Color.BLUE);				}		// Draw fuzzy segments (local map)		if (local != null)			for (i = 0; i < local.numseg (); i++)			{				xi	= local.segment (i).xi ();				yi	= local.segment (i).yi ();				xf	= local.segment (i).xf ();				yf	= local.segment (i).yf ();				dr0	= local.segment (i).v0_rho ();				dr1	= local.segment (i).v1_rho ();								model.addRawRotSegment (xi, yi, xf, yf, dr1, 0.0, Color.GREEN);						model.addRawRotSegment (xi, yi, xf, yf, dr0, 0.0, Color.GREEN.darker());					}		// Draw robot paths		if (drawpath)				drawPaths (paths);		if (drawtrace)				drawTraces (paths);				// Draw uncertainty estimation		if (uncert != null)		{			xu	= Math.sqrt (uncert[0][0]);			yu	= Math.sqrt (uncert[1][1]);			au	= Math.sqrt (uncert[2][2]);						model.addRawRotEllipse (xu, yu, pos.x (), pos.y (), pos.alpha (), Color.BLUE.darker());			model.addRawArrow (pos.x (), pos.y (), rdesc.RADIUS * AFACTOR, pos.alpha () - au, ARROW_SIZ, ARROW_ANG, Model2D.PLAIN, Color.BLUE.darker());			model.addRawArrow (pos.x (), pos.y (), rdesc.RADIUS * AFACTOR, pos.alpha () + au, ARROW_SIZ, ARROW_ANG, Model2D.PLAIN, Color.BLUE.darker());//			model.hud_label[H_ODOM]	= "Uncert: [" + ((int) Math.round (xu * 1000.0)) + ", " + ((int) Math.round (yu * 1000.0)) + ", " + ((int) Math.round (au * Angles.RTOD)) + "] mm, deg";		}//		else//			model.hud_label[H_ODOM]	= "Uncert: N/A";		// Draw the real robot		if (icon == null)		{			model.addRawCircle (pos.x (), pos.y (), rdesc.RADIUS, Color.RED);			model.addRawArrow (pos.x (), pos.y (), rdesc.RADIUS, pos.alpha (), Color.RED);		}		else			for (i = 0; i < icon.length; i++)				model.addRawTransRotLine (icon[i], pos.x (), pos.y (), pos.alpha (), Color.RED);	}}