/*
 * (c) 2002 Humberto Martinez
 */
 
package tclib.navigation.pathplanning;

import tclib.navigation.mapbuilding.*;

import devices.pos.*;
import wucore.utils.math.*;

class PathNode extends Object
{
	protected int 				x;			/* Location of cell to expand 		*/
	protected int				y;
	protected double				fn;			/* Best cost found					*/
	protected int				next;
}

public abstract class GridPath extends Object
{
	// Global variables
	public static final int			NULL			= -1;				/* Indicates a non existing cell		*/
	public static final double		EMPTY		= 0.0;				/* Indicates an empty cell 			*/
	public static final double		FULL			= 1.0;				/* Indicates a full cell 			*/
	public static final double		THRES		= 0.35;				/* Threshold for occupied cell 		*/	

	// Types of path generation methods
	static public final int			POLYLINE		= 0;
	static public final int			SPLINE		= 1;
	static public final int			BSPLINE		= 2;
	
	static public final int			MINLENGHT	= 3;
	static public final int			SEGMENTS	= 2;
	static public final int			POINTS		= 1;
	static public final int			GRID		= 0;

	// Path planning modes
	static public final int			FOLLOW_FN	= 0;
	static public final int			FOLLOW_GN	= 1;	

	// Path generation  & cost calculation parameters
	protected int					DILATION		= 2;					/* Cells influencing the costs		*/
	protected long					TIME_STEP	= 50;				/* Maximum time per algorithm step	*/
	protected int					MAX_PATH		= 500;				/* Maximum number of cells in path	*/
	protected double					EXTENSION	= 1.0;				/* Distance to extend the paths (m)	*/
	protected double					Km;								/* Unexplored cell cost				*/
	protected double					Kc;								/* Cost curve steepness				*/

	// Position related variables
	protected int					goal_x;							/* Goal location (grid units)		*/
	protected int					goal_y;	
	protected int					robot_x;							/* Robot location (grid units)		*/
	protected int					robot_y;	
	protected Position				goal;							/* Goal location (world units)		*/
	protected Position				robot;							/* Robot location (world units)		*/

	// Grid map update time 
	protected double					time;							// Current control cycle time (ms)
	protected double					tsum;							// Accumulated time updates (ms)
	protected int					tcount;							// Number of time updates
	protected int					expanded;						// Number of nodes that have been expanded
	
	protected int					size_x;							/* The cost X axis size						*/
	protected int					size_y;							/* The cost Y axis size						*/
	protected double[][]				f1;								/* Cost from cell to goal (buffer 1)		*/
	protected double[][]				f2;								/* Cost from cell to goal (buffer 2)		*/
	protected double[][]				f;								/* Cost from cell to goal 					*/
	
	protected int					curve;							/* Type of curve generated					*/
	protected int					source;							/* Source for generating a new path			*/
	protected int					heuristic;						/* Path planning heuristic			*/
	protected Grid					grid;							/* Grid map									*/

	protected double[][]				free;							/* Combination of empty/occupied beliefs	*/
	protected Path					path;							/* Path generated by the method				*/
	protected Path					rpath;							/* Path refined after the method			*/
		
	// Time bounded computations
	protected boolean				locked;							/* A new computation is being performed		*/
	protected boolean				finished;						/* A new path has been generated 			*/
	protected long					lck_time;
	protected int					lck_cnt;
	protected boolean				lck_buffer;
	public boolean					debug;
	
	// Path planning minimising the lenght of the path
	PathFinder						pfinder;
	
	// Constructors
	protected GridPath ()
	{
	}
	
	public GridPath (Grid grid)
	{
		double		diag;
		
		this.grid	= grid;
		
		size_x 		= grid.size_x (); 
		size_y 		= grid.size_y ();

		free			= grid.navigation ();
		f1	 		= new double[size_x][size_y];
		f2	 		= new double[size_x][size_y];
		
		path			= new Path (10 * Math.max (size_x, size_y));		
		path.step (grid.side ());
		
		// Cost parameters
		diag			= (double) (size_x * size_y);
		Kc			= Math.log (diag * diag);
		Km			= Double.MAX_VALUE;	
						
		// Default working values
		curve		= GridPath.POLYLINE;
		source		= GridPath.GRID;
		heuristic	= FOLLOW_FN;
		
		// Set time bounded computations parameters
		locked		= false;
		finished		= false;
		lck_buffer	= true;
		f			= f1;
		
		// Set default position parameters (goal, robot)
		robot		= new Position ();
		goal			= new Position ();
		location (new Position ());
		goal (new Position ());
		path.reset ();
		debug = false;
		
		pfinder = new PathFinder();
	}
	
	// Accessors
	public final int 				goal_x ()					{ return goal_x; }
	public final int 				goal_y ()					{ return goal_y; }
	
	public final Path	 			path ()						{ return rpath; }
	public final boolean				newPath ()					{ return finished; }
	
	public final void				setDilation (int dil)		{ DILATION = dil; }
	public final void				setTimeStep (int tstep)		{ TIME_STEP = tstep; }
	public final void				setMaxPath (int mpath)		{ MAX_PATH = mpath; }
	public final void				setExtension (double ext)	{ EXTENSION = ext; }
	public final void				setHeuristic (int heur)		{ heuristic = heur; }

	public final double[][] 			cost ()						{ if (lck_buffer) return f2; return f1; }
	public final double				kmax ()						{ return Km; }
	public final void 				curve (int c, int s)			{ curve = c; source = s; }
	
	public final double				time ()						{ return time; }
	public final double				avg ()						{ if (tcount > 0) return (tsum / (double) tcount); return 0.0; }
	public final int					expanded ()					{ return expanded; }
	
	// Instance methods 
	public void location (Position pos)
	{
		robot_x (grid.ctog_x (pos.x ()));
		robot_y (grid.ctog_y (pos.y ()));
		
		robot.set (pos);
	}

	public void goal (Position pos)
	{
		goal_x (grid.ctog_x (pos.x ()));
		goal_y (grid.ctog_y (pos.y ()));
		
		if(pos.valid())
			goal.set (pos);
		else{
			goal.set(grid.gtoc_x(goal_x), grid.gtoc_y(goal_y));
		}
		
		locked		= false;
	}

	public void add_time (double time)
	{
		this.time	= time;
		tsum		+= time;
		tcount ++;
	}
	
	/* -----------------------------------------------
	   Set coordinates for planning inside grid boundaries.
	   ------------------------------------------------ */
	public void goal_x (int x)
	{ 
		goal_x = x; 
		if (goal_x < 1)				goal_x = 1;
		if (goal_x >= size_x)		goal_x = size_x - 1;
	}
	
	public void goal_y (int y)			
	{ 
		goal_y = y; 
		if (goal_y < 1)				goal_y = 1;
		if (goal_y >= size_y)		goal_y = size_y - 1;
	}
	
	public void robot_x (int x)
	{ 
		robot_x = x; 
		if (robot_x < 1)			robot_x = 1;
		if (robot_x >= size_x)		robot_x = size_x - 1;
	}
	
	public void robot_y (int y)
	{ 
		robot_y = y; 
		if (robot_y < 1)			robot_y = 1;
		if (robot_y >= size_y)		robot_y = size_y - 1;
	}
	
	/* -----------------------------------------------
	   Print the cost grid.  
	   ------------------------------------------------ */
	public void print_cost ()
	{
		int		i, j;

		// Printout the cell values, skipping the boundary cells.
		for (j = size_y - 2; j > 0; j--)
		{
			for (i = size_x - 2; i > 0; i--)
			{
				if (f[i][j] < Km)
					System.out.print (f[i][j] + " ");
				else
					System.out.print ("N/E ");				
			}
			System.out.println ();
		}
	}

	/* -----------------------------------------------
	 Extract the full path in order to go from the robot 
	 position to the desired one. 
	 ------------------------------------------------ */
	protected Position generate_extension (Position p1, Position p2)
	{
		Position			p3;
		double				m, n;
		double				dx, dy;
		double				a, x, y;
		
		dx	= p2.x () - p1.x ();
		dy	= p2.y () - p1.y ();
		if (dx == 0.0)				// Over Y axis (90, -90 deg)
		{
			x	= p1.x ();
			if (dy > 0.0)
				y	= p2.y () + EXTENSION;
			else
				y	= p2.y () - EXTENSION;
		}
		else if (dy == 0.0)			// Over X axis (0, 180 deg)
		{
			y	= p1.y ();
			if (dx > 0.0)
				x	= p2.x () + EXTENSION;
			else
				x	= p2.x () - EXTENSION;
		}
		else						// Other angles
		{
			m	= dy / dx;
			n	= p1.y () - m * p1.x ();
			a	= Math.atan2 (p2.y () - p1.y (), p2.x () - p1.x ());
			x	= p2.x () + EXTENSION * Math.cos (a);
			y	= m * x + n;
		}
		p3	= new Position (x, y, p2.alpha ());
		
		return p3;
	}
	
	/* -----------------------------------------------
	   Extract the full path in order to go from the robot 
	   position to the desired one. 
	   ------------------------------------------------ */
	protected void generate_path ()
	{
		int			plast = 0;
		int			n;
		double		dst, firstang;
		double 		alf;

		switch (source)
		{
		case SEGMENTS:
			/* 
			//Metodo 1. Genera un segmento desde el robot al goal (solo 2 puntos)
				path.reset ();
				path.add (robot);
				path.add (goal);					
				firstang = robot.alpha ();
				break;
			*/
		
			// Metodo2. Genera un segmento desde robot a goal con 10cm por cada punto)
			path.reset ();
			path.add (robot);
			alf = Math.atan2(goal.y()-robot.y(), goal.x()-robot.x());
			n = (int)Math.round(robot.distance(goal) / 0.1);
			for(int i = 1; i < n; i++){
				dst = i * 0.1;
				path.add(robot.x()+ i*0.1 * Math.cos(alf),
					robot.y()+ i*0.1 * Math.sin(alf),
					alf);
			}
			path.add (goal);				
			firstang = robot.alpha ();
		break;
		
		case POINTS:
			
//			double distx;
			double disty, del;			
			double x, y, alpha, inicio, dif;
			double rx, ry, fin, radio;		
			int puntos;
			//	Radio Minimo = Length / tg(delta_max) = 1.008/tg(60)= 0.58
			//  Con radio 0.7=>55�, 0.8=>51.5, 0.9=>48.2�

			//  CALCULO PRIMER SEMICIRCULO RMIN	//

			alf     = Math.atan2(robot.y()-goal.y(),robot.x()-goal.x()) - goal.alpha();
			dst		= robot.distance (goal);
//			distx   = dst * Math.cos (alf);
			disty   = dst * Math.sin (alf);
			del = Angles.radnorm_180(goal.alpha() - robot.alpha()) * Angles.RTOD;

			// CASO GIRO 270�-360�
			if( ((del > -90.0)&&(del < 0.0)&&(disty>0)) || ((del > 0.0)&&(del < 90.0)&&(disty<0)) ){		
				/*path.reset();
				path.add(robot.x(),robot.y(),0.0);
				path.add(robot.x()+0.1 * Math.cos(robot.alpha()+Math.PI),robot.y()+0.1*Math.sin(robot.alpha()+Math.PI),0.0);
				path.add(robot.x()+0.4 * Math.cos(robot.alpha()+Math.PI),robot.y()+0.4*Math.sin(robot.alpha()+Math.PI),0.0);

				dst		= distx;
				x = goal.x() + dst * Math.cos(goal.alpha());
				y = goal.y() + dst * Math.sin(goal.alpha());
				path.add(x, y, goal.alpha());

				dst		= 0.75 * dst;
				plast	= (int)(dst/0.2); //puntos cada 0.2m
				for(int i = 1;i < plast; i++){
					x = goal.x() + (1-(double)i/(double)plast) * dst * Math.cos(goal.alpha());
					y = goal.y() + (1-(double)i/(double)plast) * dst * Math.sin(goal.alpha());
					path.add(x, y, goal.alpha());	
				}*/
							    
			    double ang;
			    
			    path.reset();
			    ////			 Primer Semicirculo ////			
				radio = 0.7;	// Radio primer semicirculo
				puntos = 10;  	// Numero de puntos del semicirculo
				if(Math.abs(disty) < 1.0)
					radio = 0.6;
				
				// Linea
				if(disty < 0)
				    ang = goal.alpha() + Math.PI / 2;
				else
				    ang = goal.alpha() - Math.PI / 2;
				dst = Math.abs(disty) - radio;
				x = robot.x() + dst * Math.cos(ang);
				y = robot.y() + dst * Math.sin(ang);
				
				Position pi = robot;
//				Position pf = new Position(x,y,0);	
				puntos = 5; //puntos cada 0.2m
				
				for(int i = 1;i < puntos; i++){
					x = pi.x() + ((double)i/(double)puntos) * dst * Math.cos(ang);
					y = pi.y() + ((double)i/(double)puntos) * dst * Math.sin(ang);
					path.add(x, y, ang);
				}
				
				x = robot.x() + dst * Math.cos(ang);
				y = robot.y() + dst * Math.sin(ang);
				//	Calculo del radio del segundo semicirculo		
				rx = x + radio * Math.cos(goal.alpha()+Math.PI);
				ry = y + radio * Math.sin(goal.alpha()+Math.PI);
				
				// Genera segundo semicirculo
				puntos = 10;
				alpha = goal.alpha();
				dif = Math.PI /2;
				for(int i = 0; i < puntos; i++){
					path.add(rx+radio*Math.cos(alpha),ry+radio*Math.sin(alpha),0.0);
					if(disty<0) alpha = alpha + Math.abs(dif)/(puntos-1);
					else		alpha = alpha - Math.abs(dif)/(puntos-1);
				}
				
				//// Recta Final ////
				dst		= path.last(-1).distance (goal);
				plast	= (int)(dst/0.2); //puntos cada 0.2m
				for(int i = 1;i < plast; i++){
					x = goal.x() + (1-(double)i/(double)plast) * dst * Math.cos(goal.alpha());
					y = goal.y() + (1-(double)i/(double)plast) * dst * Math.sin(goal.alpha());
					path.add(x, y, goal.alpha());	
				}
			}		
			// // CASO dy MENOR A 0.5 METROS
			else if((Math.abs(disty)<0.5))
			{	
				dst		= 0.90 * dst;
				plast	= (int)(dst/0.2); //puntos cada 0.2m
				path.reset();
				path.add(robot.x(),robot.y(),0.0);
				for(int i = 1;i < plast; i++){
					x = goal.x() + (1-(double)i/(double)plast) * dst * Math.cos(goal.alpha());
					y = goal.y() + (1-(double)i/(double)plast) * dst * Math.sin(goal.alpha());
					path.add(x, y, goal.alpha());	
				}
			}		
			else	// CASO GIRO NORMAL
			{	 						
				//// Primer Semicirculo ////			
				radio = 0.7;	// Radio primer semicirculo
				puntos = 10;  	// Numero de puntos del semicirculo
				if(Math.abs(disty) < 1.0)
					radio = 0.6;
			
				// Calculo del radio							
				if(disty<0){
					rx = robot.x() + radio * Math.cos(robot.alpha()-Math.PI/2);
					ry = robot.y() + radio * Math.sin(robot.alpha()-Math.PI/2);
					inicio = Math.atan2(robot.y()-ry,robot.x()-rx);
					fin = goal.alpha();
					dif = fin-inicio; 
				}
				else{
					rx = robot.x() + radio * Math.cos(robot.alpha()+Math.PI/2);
					ry = robot.y() + radio * Math.sin(robot.alpha()+Math.PI/2);
					inicio = Math.atan2(robot.y()-ry,robot.x()-rx);
					fin = goal.alpha();
					dif = -(fin-inicio);			
				}
				if (dif<0) dif+= Math.PI *2;
				if (dif>Math.PI*2) dif-= Math.PI *2;
	
				// Generando primer semicirculo
				path.reset();
				alpha = inicio;
				for(int i = 0; i < puntos; i++){
					path.add(rx+radio*Math.cos(alpha),ry+radio*Math.sin(alpha),0.0);
					if(disty<0) alpha = alpha + Math.abs(dif)/(puntos-1);
					else		alpha = alpha - Math.abs(dif)/(puntos-1);
				}

				//// Segundo Semicirculo ////
				alf     = Math.atan2(path.at(puntos-1).y()-goal.y(),path.at(puntos-1).x()-goal.x()) - goal.alpha();
				dst		= path.at(puntos-1).distance (goal);
//				distx   = dst * Math.cos (alf);
				disty   = dst * Math.sin (alf);
	
				radio = 0.8;	// Radio maximo segundo semicirculo
				if(Math.abs(disty) < radio) radio = Math.abs(disty);
				dst = Math.abs(disty) - radio;
				if(dst<0) dst = 0;
	
				// Calculo del radio del segundo semicirculo		
				fin = 0;
				if(disty<0){
					x = path.at(puntos-1).x() + dst * Math.cos(goal.alpha()+Math.PI/2);
					y = path.at(puntos-1).y() + dst * Math.sin(goal.alpha()+Math.PI/2);
					rx = x + radio * Math.cos(goal.alpha()+Math.PI);
					ry = y + radio * Math.sin(goal.alpha()+Math.PI);
					inicio = Math.atan2(y-ry,x-rx);
					fin = goal.alpha()+Math.PI/2;
					dif = fin-inicio;
				}
				else{
					x = path.at(puntos-1).x() + dst * Math.cos(goal.alpha()-Math.PI/2);
					y = path.at(puntos-1).y() + dst * Math.sin(goal.alpha()-Math.PI/2);
					rx = x + radio * Math.cos(goal.alpha()-Math.PI);
					ry = y + radio * Math.sin(goal.alpha()-Math.PI);
					inicio = Math.atan2(y-ry,x-rx);
					fin = goal.alpha()-Math.PI/2;
					dif = -(fin-inicio);
				}
				if (dif<0) dif+= Math.PI *2;
				if (dif>Math.PI*2) dif-= Math.PI *2;

				//// Recta entre 1 y 2 semicirculo ////
				Position pi = path.last(-1);
				Position pf = new Position(rx+radio*Math.cos(inicio),ry+radio*Math.sin(inicio),0.0);	
				puntos = (int)(pi.distance(pf)/0.2); //puntos cada 0.2m
				double ang = Math.atan2(pf.y()-pi.y(),pf.x()-pi.x());
				for(int i = 1;i < puntos; i++){
					x = pi.x() + ((double)i/(double)puntos) * pi.distance (pf) * Math.cos(ang);
					y = pi.y() + ((double)i/(double)puntos) * pi.distance (pf) * Math.sin(ang);
					path.add(x, y, goal.alpha());	
				}

				// Genera segundo semicirculo
				puntos = 10;
				alpha = inicio;
				for(int i = 0; i < puntos; i++){
					path.add(rx+radio*Math.cos(alpha),ry+radio*Math.sin(alpha),0.0);
					if(disty<0) alpha = alpha + Math.abs(dif)/(puntos-1);
					else		alpha = alpha - Math.abs(dif)/(puntos-1);
				}
		
				//// Recta Final ////
				dst		= path.last(-1).distance (goal);
				plast	= (int)(dst/0.2); //puntos cada 0.2m
				for(int i = 1;i < plast; i++){
					x = goal.x() + (1-(double)i/(double)plast) * dst * Math.cos(goal.alpha());
					y = goal.y() + (1-(double)i/(double)plast) * dst * Math.sin(goal.alpha());
					path.add(x, y, goal.alpha());	
				}
			}
			path.add (goal);
			path.add (generate_extension (path.last (-plast/2-1), goal));	
			firstang 	= robot.alpha ()+Math.PI;
			
			break;
			
		case MINLENGHT:
			
			firstang = 99999;
			
			Position[] pfinder_path;
			Position fpoint, lpoint;
			
			fpoint = new Position(robot.x(), robot.y(), robot.alpha()+Math.PI);
			//lpoint = new Position(robot.x()-8.0*Math.cos(robot.alpha()), robot.y()-8.0*Math.sin(robot.alpha()), robot.alpha()+Math.PI);
			lpoint = new Position(goal.x(), goal.y(), goal.alpha()+Math.PI);
			
			double k_max, sigma_max;
			
			// Automatic curvature selection
			double lengthAGV;
			lengthAGV = 1.004;
			k_max = Math.tan(Math.toRadians(45))/lengthAGV;	// curvature radius inverse : tan(phi)=L/R -> k_max=tan(phi_max)/L
			//k_max = Math.tan(Math.toRadians(60))/lengthAGV;	// curvature radius inverse : tan(phi)=L/R -> k_max=tan(phi_max)/L
			sigma_max = Math.toRadians(42.0)*0.9;	// curvature derivative : (dk/dt=dk/ds*ds/dt) sigma_max=(dk/dt)max/(ds/dt)max
			//sigma_max = Math.toRadians(60.0)*0.9;	// curvature derivative : (dk/dt=dk/ds*ds/dt) sigma_max=(dk/dt)max/(ds/dt)max
			
			double exten = 1.0;	// parametizable extension (metres)
			double pexten = 0.2;	// parametizable extension (metres)
			// System.out.println(" k_max: " + k_max + " sigma_max: " + sigma_max);
			
			pfinder.calculatePath(fpoint, lpoint, k_max, sigma_max, 0.1, 0.1, exten, pexten);
			
			//pfinder.initGUI ();
			//pfinder.drawTrajectory();
			
			pfinder_path = pfinder.getPath();
			
//			double pathlenth = pfinder.getLength();
//			double pathlenth_aux = ((double)((int)(1000.0*pathlenth)))/1000.0;
			
			//System.out.println ("Path Length: " +  pathlenth_aux + " metres");
			
			path.reset ();
			for(int i = 0; i < pfinder_path.length; i++)
				path.add (pfinder_path[i]);
			
			firstang = robot.alpha () + Math.PI;
			
			break;
		
		case GRID:
		default:
			firstang	= plan_path ();
//			path.add (generate_extension (path.at (path.end () - 1), goal));		
		}
		
		switch (curve)
		{
		case BSPLINE:
			rpath	= new BSpline (path, firstang);
			break;
			
		case POLYLINE:
		default:
			rpath	= path;
		}
		rpath.type (curve);
	}	

	/* -----------------------------------------------
	   Compute the cost grid based on the map
	   represented in the free grid.
	   Each path-planning iteration is time-bounded.
	   ------------------------------------------------ */
	public void replan (Position pos) 
	{
		long		st;
				
		switch (source)
		{
		case GRID:
		    if (locked){
			    if(debug) System.out.println("  [GridPath] Replanning. Execute plan_step");
				plan_step ();
			}
			else{
			    if(debug) System.out.println("  [GridPath] Replanning. Execute plan_init pos="+pos);
				plan_init (pos);
			}
			
			break;
			
		case POINTS:
		case SEGMENTS:
		default:
			if (!locked)
			{
				st	= System.currentTimeMillis ();
				
				expanded	= 0;
				locked		= true;
				finished	= true;
				
				location (pos);
				generate_path ();
				
				add_time ((double) (System.currentTimeMillis () - st));
			}
		}
	}
	
	public void reset (Position pos)
	{
		plan_init (pos);
	}

	// Abstract classes. These MUST be implemented
	protected abstract void		plan_reset ();
	protected abstract void		plan_init (Position pos);
	protected abstract void		plan_step ();
	protected abstract double		plan_path ();
}
