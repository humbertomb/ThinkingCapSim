/* * (c) 2002 Humberto Martinez  */ package tcrob.umu.quaky2;import java.util.*;import tc.shared.linda.*;import tclib.navigation.pathplanning.GridPath;import tclib.planning.sequence.*;import wucore.utils.math.*;		public class SoccerPlanner extends SeqPlanner{	// Manouvering tolerances	static public final  double		TOL_BALL_DIST	= 0.35;		// Tolerance in ball operations (m)	static public final  double		TOL_BALL_HEAD	= 180.0;	// Tolerance in ball operations (deg)	static public final  double		TOL_NET_DIST	= 1.0;		// Tolerance in net operations (m)	static public final  double		TOL_NET_HEAD	= 180.0;	// Tolerance in net operations (deg)		static public final int			STAY		= 0;	static public final int			KICK		= 1;	static public final int			SCORE	= 2;			// Current sub-plan parameters	protected Task[]					subplan;	protected int					subplan_n;	protected int					subplan_k;		protected boolean				newsubtask;					// A new subtask is available	protected boolean				completed;					// Current subtask finished				// Constructors	public SoccerPlanner (Properties props, Linda linda)	{		super (props, linda);		int				i;		subplan		= new Task[20];		for (i = 0; i < 20; i++)			subplan[i]	= new Task ();	}		// Instance methods	protected void do_plan () 	{				do_subplan ();				if (completed)		{			task_k ++;			newtask	= true;						if (task_k == task_n)			{				finished	= true;								setStatus (ItemStatus.IDLE, "Task completed");				if (debug)		System.out.println (this);			}		}	}		protected void do_subplan () 	{		if (newtask)		{				switch (parsePlan (task[task_k].plan))			{			case KICK:				subplan_n 	= 2; 												// Find the ball				subplan[0].place		= task[task_k].place;								subplan[0].plan			= task[task_k].task;			// TODO esto (la clase completa) hay que apaï¿½arlo!!					subplan[0].task			= "SEARCH";				subplan[0].tpos			= task[task_k].tpos;				subplan[0].tol_pos		= TOL_BALL_DIST;				subplan[0].tol_head		= TOL_BALL_HEAD * Angles.DTOR;				subplan[0].path_mode	= GridPath.POLYLINE;				subplan[0].path_src		= GridPath.SEGMENTS;				// Make the kick				subplan[1].place		= task[task_k].place;								subplan[1].task			= task[task_k].task;								subplan[1].task			= "KICK";				subplan[1].tpos			= task[task_k].tpos;				subplan[1].tol_pos		= TOL_BALL_DIST;				subplan[1].tol_head		= TOL_BALL_HEAD * Angles.DTOR;				subplan[1].path_mode	= GridPath.POLYLINE;				subplan[1].path_src		= GridPath.POINTS;				break;							case SCORE:				subplan_n 	= 3; 												// Find the ball				subplan[0].place		= task[task_k].place;								subplan[0].task			= task[task_k].task;								subplan[0].task			= "SEARCH";				subplan[0].tpos			= task[task_k].tpos;				subplan[0].tol_pos		= TOL_BALL_DIST;				subplan[0].tol_head		= TOL_BALL_HEAD * Angles.DTOR;				subplan[0].path_mode	= GridPath.POLYLINE;				subplan[0].path_src		= GridPath.SEGMENTS;				// Align the ball and the net				subplan[1].place		= task[task_k].place;								subplan[1].task			= task[task_k].task;								subplan[1].task			= "ALIGN";				subplan[1].tpos			= task[task_k].tpos;				subplan[1].tol_pos		= TOL_BALL_DIST;				subplan[1].tol_head		= TOL_BALL_HEAD * Angles.DTOR;				subplan[1].path_mode	= GridPath.POLYLINE;				subplan[1].path_src		= GridPath.POINTS;				// Make the kick				subplan[2].place		= task[task_k].place;								subplan[2].task			= task[task_k].task;								subplan[2].task			= "KICK";				subplan[2].tpos			= task[task_k].tpos;				subplan[2].tol_pos		= TOL_BALL_DIST;				subplan[2].tol_head		= TOL_BALL_HEAD * Angles.DTOR;				subplan[2].path_mode	= GridPath.POLYLINE;				subplan[2].path_src		= GridPath.POINTS;				break;							case STAY:			default:				subplan_n	= 1;								// Stay on place				subplan[0].place		= task[task_k].place;								subplan[0].task			= task[task_k].task;								subplan[0].task			= "STANDBY";				subplan[0].tpos			= lps.cur;				subplan[0].tol_pos		= TOL_BALL_DIST;				subplan[0].tol_head		= TOL_BALL_HEAD * Angles.DTOR;				subplan[0].path_mode	= GridPath.POLYLINE;				subplan[0].path_src		= GridPath.GRID;			}						newtask		= false;			completed	= false;			subplan_k	= 0;							setGoal (subplan[subplan_k]);			setStatus (ItemStatus.OCCUPIED, subplan[subplan_k].toString ());			if (debug)		System.out.println (this);		}		else		{			if (taskStatus () != ItemBehResult.T_NOTYET)			{				subplan_k ++;								if (subplan_k == subplan_n)				{					completed	= true;									setStatus (ItemStatus.IDLE, "Subtask completed");				}				else				{					setGoal (subplan[subplan_k]);					setStatus (ItemStatus.OCCUPIED, subplan[subplan_k].toString ());				}				if (debug)		System.out.println (this);			}		}	}		protected int parsePlan (String plan)	{		String lplan;		lplan = plan.toLowerCase ();		if (lplan.equals ("stay"))		return STAY;		else if (lplan.equals ("kick"))	return KICK;		else if (lplan.equals ("score"))	return SCORE;				return KICK;	}		public String toString ()	{		String			str;				str		= super.toString ();				if (subplan_k >= subplan_n)			str 	+= "Subtask completed.";		else			str		+= "Subtask: " + subplan[subplan_k].task;				return str;	}}