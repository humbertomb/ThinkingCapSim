/** * (c) 2000-2001 Humberto Martinez */package devices.pos;import java.io.*;public class LLAPath extends Object {	static public final String		SUFFIX		= ".path";		// Proposed robot's path pos	protected LLAPos[]				pos;		protected int					p_beg;					// Begin of circular buffer	protected int					p_end;					// End of circular buffer	protected int					p_num;					// Number of points in the circular buffer	protected int					p_ndx;					// Iterator index (cursor)	protected int					p_cnt;					// Iterator count (cursor)			/* Constructors */	public LLAPath (int pn)	{		this.pos = new LLAPos[pn];								reset ();	}		/* Accessor methods */	public final int	 	num () 				{ return p_num; }		/* Class methods */	public static LLAPath load (String name)	{		int					count;		double			    x, y;		FileReader		 	input;		StreamTokenizer		st;		LLAPath				path = null;					// Count the total number of path items		try { input = new FileReader (name); } catch (Exception e) { return null; }		st		= new StreamTokenizer (new BufferedReader (input));		st.eolIsSignificant (false);		count	= 0;		try		{						while (st.nextToken () != StreamTokenizer.TT_EOF)			{				st.nextToken ();				st.nextToken ();				count ++;			}		}		catch (Exception e) { e.printStackTrace (); }		try { input.close (); } catch (Exception e) { }			// Read actual path items		try { input = new FileReader (name); } catch (Exception e) { return null; }		st		= new StreamTokenizer (new BufferedReader (input));		st.eolIsSignificant (false);		path		= new LLAPath (count);		try		{						while (st.nextToken () != StreamTokenizer.TT_EOF)			{				x		= st.nval;		st.nextToken ();				y		= st.nval;		st.nextToken ();								path.add (new LLAPos (y, x));			}		}		catch (Exception e) { e.printStackTrace (); }		try { input.close (); } catch (Exception e) { }		return path;	}	/* Instance methods */	public void allocateAll ()	{		p_num = pos.length;		for (int i = 0; i < pos.length; i++)			pos[i] = new LLAPos ();	}		// Methods for implementing file operations	public void save (String name)	{		PrintWriter		file	= null;		try		{			file = new PrintWriter (new BufferedWriter (new FileWriter (name)));  				for (LLAPos pos = first (); pos != null; pos = next ())			{				file.println (pos.x + "\t" + pos.y);			}			file.flush ();			file.close ();		} catch (Exception e) 		{ 			if (file != null)			{				file.flush ();				file.close (); 			}		}	}	// Methods for implementing a circular buffer of Points	public void reset ()	{		p_beg		= 0;		p_end		= -1;		p_num		= 0;		p_cnt		= 0;		p_ndx		= p_beg;	}	public LLAPos first ()	{		if (p_num <= 0)							return null;				p_cnt = 1;		p_ndx = p_beg+1;				return pos[p_beg]; 	}		public LLAPos first (int count)	{		if (count <= 0)			return first ();				first ();				for (; count > 1; count --)			next ();				return next ();	}	public LLAPos next ()	{		LLAPos		cur;				if ((p_num <= 0)	|| (p_cnt >= p_num))		return null;				if (p_ndx >= pos.length)			p_ndx = 0;				cur	= pos[p_ndx];		p_ndx ++;		p_cnt ++;				return cur;	}		public LLAPos previous ()	{		if (p_num <= 0)							return null;				p_ndx --;		p_cnt --;			if (p_ndx < 0)			p_ndx = pos.length - 1;				return pos[p_ndx];	}		public LLAPos last ()	{ 		if (p_num <= 0)							return null;				p_ndx = p_end;		p_cnt = p_num;				return pos[p_end]; 	}	public LLAPos last (int count)	{		if (count >= 0)			return last ();				last ();				for (; count < -1; count ++)			previous ();				return previous ();	}	public void add (LLAPos llapos)	{		p_num ++;		if (p_num >= pos.length)		{			p_beg ++;			if (p_beg >= pos.length)				p_beg = 0;		}		p_end ++;		if (p_end >= pos.length)			p_end = 0;				pos[p_end] = llapos;	}	public void addAlloc (LLAPos llapos)	{		p_num ++;		if (p_num >= pos.length)		{			p_beg ++;			if (p_beg >= pos.length)				p_beg = 0;		}		p_end ++;		if (p_end >= pos.length)			p_end = 0;				if (pos[p_end] == null)			pos[p_end] = new LLAPos ();		pos[p_end].set (llapos);	}	public LLAPos at (int i)	{		if ((i < 0) || (i >= p_num)) 		return null;		return pos[i];	}			public void at (int i, LLAPos npos)	{		if ((i < 0) || (i >= p_num)) 		return;				pos[i].set (npos);	}			public void reverse ()	{		for (int i = 0; i < p_num/2; i++)		{			LLAPos temp = pos[i];			pos[i] = pos[p_num-i-1];			pos[p_num-i-1] = temp;		}	}		public String toString ()	{		String ret = "Path = [";		for (LLAPos pos = first (); pos != null; pos = next ())			ret += pos.x + "\t" + pos.y;		ret += "] beg="+p_beg+" end="+p_end+" p_num="+p_num;		return ret;	}}