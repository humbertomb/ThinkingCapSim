/* * (c) 2000-2001 Humberto Martinez */package devices.pos;import java.io.*;import wucore.utils.geom.*;import wucore.utils.logs.*;public class Path extends Object {	static public final String		SUFFIX		= ".path";		// Proposed robot's path pos	protected Position[]				pos;		protected int					p_beg;					// Begin of circular buffer	protected int					p_end;					// End of circular buffer	protected int					p_num;					// Number of points in the circular buffer	protected int					p_ndx;					// Iterator index (cursor)	protected int					p_cnt;					// Iterator count (cursor)		// Look-ahead related calculations	protected int					p_looka;					// Look-ahead point	protected double					p_dist		= 0.0;		// Distance from robot to path		// Additonal variables	protected double					step			= 1.0;		// Path-step size (for drawing purposes)	protected int					type			= 0;			// Type of path (polyline, spline, etc)		/* Constructors */	public Path (int pn)	{		int			i;				this.pos		= new Position[pn];		for (i = 0; i < pn; i++)			pos[i] 	= new Position ();				reset ();	}		/* Accessor methods */	public final int	 		num () 				{ return p_num; }		public final void		step (double step)	{ this.step = step; }	public final double		step ()				{ return step; }	public final void		type (int type)		{ this.type = type; }	public final int			type ()				{ return type; }	public final Position		lookahead ()			{ if (p_looka < 0) return null; else return pos[p_looka]; }	public final double		distance ()			{ return p_dist; }	/* Class methods */	public static Path load (String name)	{		int					count;		double			    x, y, a;		FileReader		 	input;		StreamTokenizer		st;		Path					path = null;					// Count the total number of path items		try { input = new FileReader (name); } catch (Exception e) { return null; }		st		= new StreamTokenizer (new BufferedReader (input));		st.eolIsSignificant (false);		count	= 0;		try		{						while (st.nextToken () != StreamTokenizer.TT_EOF)			{				st.nextToken ();				st.nextToken ();				count ++;			}		}		catch (Exception e) { e.printStackTrace (); }		try { input.close (); } catch (Exception e) { }			// Read actual path items		try { input = new FileReader (name); } catch (Exception e) { return null; }		st		= new StreamTokenizer (new BufferedReader (input));		st.eolIsSignificant (false);		path		= new Path (count);		try		{						while (st.nextToken () != StreamTokenizer.TT_EOF)			{				x		= st.nval;		st.nextToken ();				y		= st.nval;		st.nextToken ();				a		= st.nval;								path.add (x, y, a);			}		}		catch (Exception e) { e.printStackTrace (); }		try { input.close (); } catch (Exception e) { }		return path;	}	/* Instance methods */	// Methods for implementing file operations	public void save (String name)	{		PrintWriter		file	= null;		try		{			file = new PrintWriter (new BufferedWriter (new FileWriter (name)));  				for (Position pos = first (); pos != null; pos = next ())			{				file.println (pos.x() + "\t" + pos.y() + "\t" + pos.alpha());			}			file.flush ();			file.close ();		} catch (Exception e) 		{ 			if (file != null)			{				file.flush ();				file.close (); 			}		}	}	// Methods for implementing a circular buffer of Points	public void reset ()	{		p_beg		= 0;		p_end		= 0;		//p_end		= -1;		p_num		= 0;		p_looka		= -1;				p_cnt		= 0;		p_ndx		= p_beg;	}		public Position getPosition (int index)	{		if(index >= pos.length)			return null;		else			return pos[index];	}		public Position first ()	{		if (p_num <= 0)							return null;				p_cnt = 1;		p_ndx = p_beg+1;				return pos[p_beg]; 	}		public Position first (int count)	{		if (count <= 0)			return first ();				first ();				for (; count > 1; count --)			next ();				return next ();	}	public Position next ()	{		Position		cur;				if ((p_num <= 0)	|| (p_cnt >= p_num))		return null;				if (p_ndx >= pos.length)			p_ndx = 0;				cur	= pos[p_ndx];		p_ndx ++;		p_cnt ++;				return cur;	}		public Position previous ()	{		if (p_num <= 0)							return null;				p_ndx --;		p_cnt --;			if (p_ndx < 0)			p_ndx = pos.length - 1;				return pos[p_ndx];	}		public Position last ()	{ 		if (p_num <= 0)							return null;				p_ndx = p_end;		p_cnt = p_num;				return pos[p_end]; 	}	public Position last (int count)	{		if (count >= 0)			return last ();				last ();				for (; count < -1; count ++)			previous ();				return previous ();	}	public void add (Position pos)	{		add (pos.x (), pos.y (), pos.z (), pos.alpha ());	}	public void add (double x, double y, double a)	{		add (x, y, 0.0, a);	}		public void add (double x, double y, double z, double a)	{		if (p_end == pos.length)		{			p_end = 0;			p_beg = 1;		}		pos[p_end].set (x, y, z, a);				if (p_end < p_beg)		{			p_beg ++;			if (p_beg == pos.length)  p_beg = 0;		}		p_end ++;				p_num ++;	}		/*	public void add (double x, double y, double z, double a)	{		p_num ++;		if (p_num >= pos.length)		{			p_beg ++;			if (p_beg >= pos.length)				p_beg = 0;		}				p_end ++;		if (p_end >= pos.length)			p_end = 0;				pos[p_end].set (x, y, z, a);	}	*/	public void add (double[] point)	{		add (point[0], point[1], point[2]);	}		public Position at (int i)	{		int			k;				if ((i < 0) || (i >= p_num)) 		return null;				for (k = p_beg; i > 0; i--)		{			k ++;			if (k > pos.length)				k = 0;		}		return pos[k];	}		public void at (int i, Point2 point, double rho)	{		at (i, point.x (), point.y (), rho);	}		public void at (int i, Position npos)	{		int			k;				if ((i < 0) || (i >= p_num)) 		return;				for (k = p_beg; i > 0; i--)		{			k ++;			if (k > pos.length)				k = 0;		}		pos[k].set (npos);	}		public void at (int i, double x, double y, double rho)	{		int			k;				if ((i < 0) || (i >= p_num)) 		return;				for (k = p_beg; i > 0; i--)		{			k ++;			if (k > pos.length)				k = 0;		}		pos[k].set (x, y, rho);	}	// Methods to implement look-ahead calculations (path points)	public void check_lookahead (Position rpos, int looka_dist)	{		int			i, k;		double		dist, min;		if ((p_beg == 0) && (p_end == 0))		{			p_looka = -1;			return;		}					min		= Double.MAX_VALUE;		k		= p_beg;		for (i = p_beg; i < p_end; i++)		{			if (i >= pos.length)		i = 1;						dist	= rpos.distance (pos[i]);			if (dist < min)			{				min		= dist;				k		= i;			}		}		p_dist	= min;		p_looka	= k + looka_dist;		if (p_looka > pos.length)			p_looka = p_looka - pos.length + 1;		if (p_looka >= p_end)			p_looka = p_end - 1;	}			// Methods for implementing look-ahead calculations (metres)	public void check_lookahead (Position rpos, double looka_dist)	{		int			i, k;		double		dist, min, d;			if ((p_beg == 0) && (p_end == 0))		{			p_looka = -1;			return;		}					min		= Double.MAX_VALUE;		k		= p_beg;		for (i = p_beg; i < p_end; i++)		{			if (i >= pos.length)		i = 1;						dist	= rpos.distance (pos[i]);			if (dist < min)			{				min		= dist;				k		= i;			}		}		p_dist	= min;				dist = 0.0;		min = looka_dist;		for (i = k; i < (p_end-1); i++)		{			dist += pos[i].distance(pos[i+1]);			d = Math.abs(dist - looka_dist);			if (d > min)				break;			min = d;					}		p_looka = i;				if (p_looka > pos.length)			p_looka = p_looka - pos.length + 1;		if (p_looka >= p_end)			p_looka = p_end - 1;	}			public String toString ()	{		String ret = "Path = [";		for (Position pos = first (); pos != null; pos = next ())			ret += pos.x() + "\t" + pos.y() + "\t" + pos.alpha();		ret += "] beg="+p_beg+" end="+p_end+" p_num="+p_num;		return ret;	}		public void toFile(String preffix, String suffix)	{		LogFile logfile = new LogFile(preffix,suffix);		logfile.open();		for (Position pos = first (); pos != null; pos = next ())			logfile.writeln (pos.x() + "\t" + pos.y() + "\t" + pos.alpha());		logfile.close();	}}