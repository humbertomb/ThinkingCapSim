/** * Copyright: Copyright (c) 2001 * @author Humberto Martinez Barbera (humberto@um.es) * @version 1.0 */package devices.drivers.radar.Fujitsu;import javax.comm.*;import java.io.*;import devices.data.*;import devices.drivers.radar.*;public class Fujitsu extends Radar{	public static final double			MTOK		= 3.6;				// m/s to Km/h conversion	public static final double			KTOM		= 1.0 / 3.6;		// Km/h to m/s conversion	public static final double			DTOR		= Math.PI / 180.0;	// deg to rad conversion		// Fujitsu radar frame codes	public static final byte			C_ST1		= (byte) 0xff;	public static final byte			C_ST2		= (byte) 0xff;	public static final byte			C_FUNC		= (byte) 0xfd;	// Fujitsu radar coding parameters	public static final double			RNG_K		= 0.2;		// Object range (m)	public static final int				RNG_M		= 0x4ff;	// Maximum range (255.8 m)	public static final double			SPD_K		= 0.2;		// Object speed (m/s)	public static final int				SPD_O		= 0x8000;	// Offset for speed	public static final double			ANG_K		= -0.1;		// Object angle (deg)	public static final int				ANG_O		= 0x80;		// Offset for angle		// Fujitsu radar frame offsets	public static final int				O_ST1		= 0;	public static final int				O_ST2		= 1;	public static final int				O_FUNC		= 2;	public static final int				O_D01		= 3;	public static final int				O_D02		= 4;	public static final int				O_DBASE		= 5;	public static final int				O_CK		= 44;	public static final int				O_CVR		= 45;	public static final int				O_VN		= 46;	// Fujitsu radar data registers sub-offsets	public static final int				O_Dn1H		= 0;	public static final int				O_Dn1L		= 1;	public static final int				O_Dn2H		= 2;	public static final int				O_Dn2L		= 3;	public static final int				O_Dn3		= 4;		public static final int				TIMEOUT		= 3000;		// Serial port timeout	public static final int				MAXBUFFER	= 50;		// Serial port buffer size	public static final int				MAXTARGETS	= 8;		// Maximum number of targets	protected InputStream				is;	protected OutputStream				os;	private byte[]						obuffer;	private int[]						ibuffer;		protected byte						count;	// Constructors	public Fujitsu ()	{		// Initialise data structures		ibuffer	= new int[MAXBUFFER];		obuffer	= new byte[MAXBUFFER];				count	= -128;				// Initialise Fujitsu frames		obuffer[0]	= C_ST1;		obuffer[1]	= C_ST2;		obuffer[2]	= C_FUNC;		obuffer[3]	= 0x00;		obuffer[4]	= 0x00;		obuffer[5]	= 0x00;		obuffer[6]	= 0x00;		obuffer[7]	= 0x00;	}		// Accessors    public int			maxTargets ()		{ return MAXTARGETS; }	// Instance methods	protected void initialise (String port) throws RadarException	{		CommPortIdentifier	id;		SerialPort			serial;		try		{			id		= CommPortIdentifier.getPortIdentifier (port);			serial	= (SerialPort) id.open ("Fujitsu Radar", 10000);			serial.setSerialPortParams (9600, 8, 1, SerialPort.PARITY_ODD);			serial.setFlowControlMode (SerialPort.FLOWCONTROL_NONE);			serial.enableReceiveTimeout (TIMEOUT);			is		= serial.getInputStream ();			os		= serial.getOutputStream ();		} catch (Exception e)		{ 			throw new RadarException ("--[Radar] Error opening " + port + ":" + e); 		}	}	    protected void update (RadarData current) throws RadarException    {    	int			i, k;     	int			rng, spd, ang;    	int			tmpL, tmpH;     	double		drng, dspd, dang;   	    	// Proceed with communication    	try    	{    		sendFrame (0.0, 0.0);    		getFrame ();		} catch (Exception e) { throw new RadarException ("--[Radar] Error accessing (R/W) " + getPort () + ":" + e); }				// Compute radar data		k = 0;		for (i = 0; i < MAXTARGETS; i++)		{			// Extract target range			tmpL	= ibuffer[O_DBASE * i + O_Dn1L];			tmpH	= ibuffer[O_DBASE * i + O_Dn1H];			rng		= tmpH * 0xff + tmpL;						if (rng >= (RNG_M - 10))				current.targets[i].disable ();			else			{				// Extract target speed				tmpL	= ibuffer[O_DBASE * i + O_Dn2L];				tmpH	= ibuffer[O_DBASE * i + O_Dn2H];				spd		= tmpH * 0xff + tmpL;				// Extract target angle				ang		= ibuffer[O_DBASE * i + O_Dn3];				// Convert target data				drng	= (double) rng * RNG_K;				dspd	= (double) (spd - SPD_O) * SPD_K * KTOM;				dang	= ((double) (ang - ANG_O) * ANG_K) * DTOR;				current.targets[i].set (drng, dspd, dang);												k ++;			}		}		current.num = k;    }        private void sendFrame (double speed, double curve) throws Exception    {    	int			vel;    	int			rad, radH, radL;    	int			ck;    	    	vel 	= (int) Math.round (speed * MTOK);    	rad 	= (int) Math.round (curve) + 0x8000;    	radH	= rad / 0xff;    	radL	= rad % 0xff;    			obuffer[3]	= (byte) vel;		obuffer[4]	= (byte) radH;		obuffer[5]	= (byte) radL;		obuffer[6]	= count;				ck = (obuffer[3] + obuffer[4] + obuffer[5] + obuffer[6]) % 0xff;		if (ck == 0xff)		ck = 0x00;				obuffer[7]	= (byte) ck;		os.write (obuffer);		count ++;    }        private void getFrame () throws Exception    {    	int			tmp;    	boolean		header;    	int			nrec;    	    	nrec	= 0;    	header	= false;    	while (nrec < 48)    	{    		tmp = is.read () & 0xff;// 			System.out.print ("[" + Integer.toHexString (tmp) + "]");   		   			if (!header && (tmp == 0xff))		header = true;    		    		if (header)    		{    			ibuffer[nrec] = tmp;    			nrec ++;    		}    	}    	//    	System.out.println ("Received [" + ibuffer + "]");    }}