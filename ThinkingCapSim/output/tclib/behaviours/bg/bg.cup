/* ----------------------------------------------------------	bg.cup	Grammar definition for the BG language.	v0.5 May 1998	Humberto Martinez Barbera	v0.7 Jun 1999	Humberto Martinez Barbera	v0.8 Oct 1999	Humberto Martinez Barbera	v0.9 Mar 2000	Humberto Martinez Barbera	v2.0 Ago 2001	Humberto Martinez Barbera----------------------------------------------------------- */package tc.controller.bg;import tc.controller.bg.runtime.*;action code{:	protected VSymbol			tsymbol		= null;			/* Global Symbol List */	protected VSymbol			lsymbol		= null;			/* Local Symbol List */	protected VSymbol			psymbol		= null;			/* Function Parameter Symbol List */	protected VSymbol			tfexp		= null;			/* Temporal Symbol for Fuzzy Expresion*/	protected Function			tfunc		= null;			/* Global Function Names List */	protected Expresion			fexp			= null;			/* Temporal Fuzzy Expresion for MIMO/SIMO rules */	public void error (String str)	{		BGParser.error (str + " (line " + scanner.line () + ")");	}	public VSymbol check (String name)	{		VSymbol			ret;		ret = null;		if (psymbol != null) ret = psymbol.find (name);		if ((ret == null) && (lsymbol != null)) ret = lsymbol.find (name);		if ((ret == null) && (tsymbol != null)) ret = tsymbol.find (name);		if (ret == null) error ("Variable <" + name + "> not resolved");		return ret;	}:};parser code{:	public void report_error (String str, Object info)	{		BGParser.error (str + " (line " + scanner.line () + ")");	}:};init with 					{: scanner.init ();              :};scan with 					{: return scanner.next_token (); :};terminal String				ID;terminal Double	 			DOUBLE;terminal 					TUPLE, EXTERN, AGENT, FUNCTION, RANGE,		 					BEHAVIOUR, BLENDER, BLENDING, PRIORITY, RULES, IF, ELSE, SET, FLOAT,							FSM, START, STATE, SHIFT, BACKGROUND, COMMON,							FUSION, RETURN, INITIALIZATION,							TRAPEZOID, SIGMOID, BELL, TRIANGLE, CRISP, TSK,							BBEGIN, BEND, COLON, BSTATE, SENSOR, EFFECTOR, STATUS, PRINTF, HALT,							ASSIGN, SEXP, EEXP, SCOLON, EQUAL, NE, LT, GT, LE, GE, IS,							NOT, AND, OR, TIMES, DIV, PLUS, MINUS, UMINUS;non terminal 	     		empty;non terminal Program    	program;non terminal NList			frange, fuzzy;non terminal Double			number;non terminal Integer		set;non terminal VSymbol		vars, vdec, vlist, var, vxlist, varx, postcond, blendl, blist, blenv,							vtdec, vfdec, output, olist, out, local, param, palist, par, actual,							vxslist, varxs, vxelist, varxe, vxtlist, varxt;non terminal Behaviour		behaviours, behaviour;non terminal Blender		blender, blend;non terminal Common			commonb, common;non terminal Agent			agents, agent;non terminal Function		funcs, funcls, func;non terminal Expresion		expresion, fexpresion;non terminal Command		block, commands, command, fblock, rules, rule, states, state, function,							postlist, postelem, initializ;precedence left				BBEGIN, BEND;precedence left				COLON, BSTATE;precedence left				ASSIGN; precedence right			SEXP;precedence left				EEXP;precedence left				SCOLON;precedence left				EQUAL, NE, LT, GT, LE, GE, IS;precedence right			NOT;precedence left				AND, OR;precedence left				TIMES, DIV;precedence left				PLUS, MINUS; precedence left				UMINUS;start with program;/* -------------- Starting Point ------------ */empty		::= /* Nothing */                		;program		::= vars:v funcs:f initializ:i agents:a						{: RESULT = new Program (v, f, i, a); :}            ;/* -------------- Variable Declarations ------------ */vars 		::= vars:v1 vdec:v2   						{: RESULT = tsymbol = (VSymbol) v2.addlast (v1); :}        	| vdec:v 						{: RESULT = tsymbol = v; :}       		| error                        {: error ("Error in variable declaration"); :}			;vdec        ::= vtdec:v						{: RESULT = v; :}			| vfdec:v						{: RESULT = v; :}            ;vtdec       ::= TUPLE ID:na ASSIGN ID:so SCOLON set:s fuzzy:f COLON						{: RESULT = (new VSymbol ()).tuple (na, so, s, f); :}			| TUPLE ID:na ASSIGN ID:so SCOLON ID:s COLON						{: RESULT = (new VSymbol ()).tuple (na, so, s, tsymbol); :}      		| SET ID:na ASSIGN set:s fuzzy:f COLON						{: RESULT = (new VSymbol ()).set (na, s, f); :}            | EXTERN FLOAT vxlist:v COLON						{: RESULT = v; :}            | SENSOR FLOAT vxslist:v COLON						{: RESULT = v; :}            | EFFECTOR FLOAT vxelist:v COLON						{: RESULT = v; :}            | STATUS FLOAT vxtlist:v COLON						{: RESULT = v; :}			;set	  		::= TRAPEZOID						{: RESULT = new Integer (VSymbol.S_TRAPEZOID); :}		  	| SIGMOID						{: RESULT = new Integer (VSymbol.S_SIGMOID); :}		  	| BELL						{: RESULT = new Integer (VSymbol.S_BELL); :}		  	| TRIANGLE						{: RESULT = new Integer (VSymbol.S_TRIANGLE); :}		  	| CRISP						{: RESULT = new Integer (VSymbol.S_CRISP); :}		  	| TSK						{: RESULT = new Integer (VSymbol.S_TSK); :}			;				vfdec      	::= FLOAT vlist:v COLON						{: RESULT = v; :}            ;vlist		::= var:v1 SCOLON vlist:v2                		{: RESULT = (VSymbol) v1.addlast (v2); :}            | var:v                		{: RESULT = v; :}            ;var			::= ID:na						{: RESULT = (new VSymbol ()).number (na, 0.0); :}           | ID:na ASSIGN number:n						{: RESULT = (new VSymbol ()).number (na, n); :}            ;vxlist   	::= varx:v1 SCOLON vxlist:v2                		{: RESULT = (VSymbol) v1.addlast (v2); :}            | varx:v                		{: RESULT = v; :}            ;varx		::= ID:na						{: RESULT = (new VSymbol ()).number (na, VSymbol.N_EXTERNAL, 0.0); :}            ;vxslist   	::= varxs:v1 SCOLON vxslist:v2                		{: RESULT = (VSymbol) v1.addlast (v2); :}            | varxs:v                		{: RESULT = v; :}            ;varxs		::= ID:na						{: RESULT = (new VSymbol ()).number (na, VSymbol.N_SENSOR, 0.0); :}            ;vxelist   	::= varxe:v1 SCOLON vxelist:v2                		{: RESULT = (VSymbol) v1.addlast (v2); :}            | varxe:v                		{: RESULT = v; :}            ;varxe		::= ID:na						{: RESULT = (new VSymbol ()).number (na, VSymbol.N_EFFECTOR, 0.0); :}            | ID:na ASSIGN number:n						{: RESULT = (new VSymbol ()).number (na, VSymbol.N_EFFECTOR, n); :}            ;vxtlist   	::= varxt:v1 SCOLON vxtlist:v2                		{: RESULT = (VSymbol) v1.addlast (v2); :}            | varxt:v                		{: RESULT = v; :}            ;varxt		::= ID:na						{: RESULT = (new VSymbol ()).number (na, VSymbol.N_STATUS, 0.0); :}            | ID:na ASSIGN number:n						{: RESULT = (new VSymbol ()).number (na, VSymbol.N_STATUS, n); :}            ;/* -------------- Initialization Block Declarations ------------ */initializ	::= INITIALIZATION BBEGIN commands:c BEND						{: RESULT = c; :}		  	| empty				 		{: RESULT = null; :}            ;/* -------------- Behaviour Declarations ------------ */behaviours	::= behaviour:b1 behaviours:b2						{: RESULT = (Behaviour) b1.addlast (b2); :}		  	| behaviour:b                		{: RESULT = b; :}            ;behaviour   ::= BEHAVIOUR ID:na PRIORITY number:n BBEGIN output:o local:l commands:c BEND						{: tsymbol.addlast ((new VSymbol ()).number (na, 1.0));						   psymbol = null;              		  	   RESULT = new Behaviour (na, n, o, l, c); :}            | BEHAVIOUR ID:na BBEGIN output:o local:l commands:c BEND						{: tsymbol.addlast ((new VSymbol ()).number (na, 1.0));						   psymbol = null;            			   RESULT = new Behaviour (na, 1.0, o, l, c); :}            ;output      ::= FUSION olist:o COLON						{: RESULT = o; :}		  	| empty				 		{: RESULT = null; :}            ;olist   	::= out:o1 SCOLON olist:o2                		{: RESULT = (VSymbol) o1.addlast (o2); :}            | out:o                		{: RESULT = o; :}            ;out			::= ID:na						{: RESULT = (new VSymbol ()).ref (check (na)); :}            ;local       ::= vfdec:v						{: RESULT = lsymbol = v; :}		  	| empty				 		{: RESULT = lsymbol = null; :}            ;/* -------------- Blender Declarations ------------ */blender		::= blend:b						{: RESULT = b; :}		  	| empty				 		{: RESULT = null; :}            ;blend	    ::= BLENDER BBEGIN local:l commands:c BEND                        {: RESULT = new Blender (l, c); :}            ;/* -------------- Common Block Declarations ------------ */common		::= commonb:c						{: RESULT = c; :}		  	| empty				 		{: RESULT = null; :}            ;commonb	    ::= COMMON BBEGIN local:l commands:c BEND            			{: RESULT = new Common (l, c); :}            ;/* -------------- Agent Declarations ------------ */agents    	::= agent:a1 agents:a2                		{: RESULT = (Agent) a1.addlast (a2); :}         	| agent:a                		{: RESULT = a; :}          	| error                        {: error ("Bad agent declaration"); :}             ;agent   	::= AGENT ID:na BBEGIN blendl:s common:c behaviours:b blender:l BEND                        {: RESULT = new Agent (na, s, c, b, l); :}            ;blendl		::= BLENDING blist:b COLON						{: RESULT = b; :}            ;blist 		::= blenv:b1 SCOLON blist:b2                		{: RESULT = (VSymbol) b1.addlast (b2); :}       		| blenv:b                		{: RESULT = b; :}            ;blenv		::= ID:na RANGE SEXP number:n1 SCOLON number:n2 EEXP						{: RESULT = (new VSymbol ()).ref (check (na), n1, n2); :}			| ID:na						{: RESULT = (new VSymbol ()).ref (check (na), new Double (-100.0), new Double (100.0)); :}            ;/* -------------- Function Declarations ------------ */funcs    	::= funcls:f                		{: RESULT = f; :}        	| empty                		{: RESULT = null; :}            ;funcls   	::= func:f1 funcls:f2                		{: RESULT = tfunc = (Function) f1.addlast (f2); :}         	| func:f                		{: RESULT = tfunc = f; :}            ;func		::= FUNCTION ID:na SEXP param:p EEXP BBEGIN local:l commands:c BEND                        {: RESULT = new Function (na, p, l, c); :}            ;param    	::= palist:o						{: RESULT = psymbol = o; :}		  	| empty				 		{: RESULT = psymbol = null; :}            ;palist   	::= par:o1 SCOLON palist:o2                		{: RESULT = (VSymbol) o1.addlast (o2); :}       		| par:o                		{: RESULT = o; :}            ;par			::= ID:na						{: RESULT = (new VSymbol ()).number (na, VSymbol.N_PARAM, 0.0); :}            ;/* ----------------- Commands ------------------- */block     	::= BBEGIN commands:c BEND                		{: RESULT = c; :}        	| command:c                		{: RESULT = c; :}            ;commands    ::= command:c1 commands:c2                		{: RESULT = (Command) c1.addlast (c2); :}           	| command:c                		{: RESULT = c; :}            ;command		::= IF SEXP expresion:e EEXP block:b						{: RESULT = (new Command ()).ifthen (e, b); :}		  	| IF SEXP expresion:e EEXP block:b1 ELSE block:b2						{: RESULT = (new Command ()).ifelse (e, b1, b2); :}       		| ID:na ASSIGN expresion:e COLON						{: RESULT = (new Command ()).assign (check (na), e); :}       		| PRINTF SEXP ID:na EEXP COLON						{: RESULT = (new Command ()).printf (check (na)); :}       		| HALT COLON						{: RESULT = (new Command ()).halt (); :}     		| function:f COLON						{: RESULT = f; :}       		| RULES fblock:b						{: RESULT = (new Command ()).rules (b); :}       		| FSM START ID:na BBEGIN states:b BEND						{: RESULT = (new Command ()).fsm (na, b); :}       		| SHIFT ID:na COLON						{: RESULT = (new Command ()).shift (na); :}       		| RETURN expresion:e COLON						{: RESULT = (new Command ()).retn (e); :}       		| error                        {: error ("Command syntax error"); :}             ;function	::= ID:na SEXP actual:p EEXP						{: RESULT = (new Command ()).call (na, p); :}		%prec UMINUS            ;actual     	::= blist:p						{: RESULT = p; :}		  	| empty				 		{: RESULT = null; :}            ;/* ----------- Fuzzy Rules ------------ */fblock   	::= BBEGIN rules:r BEND                		{: RESULT = r; :}        	| rule:r                		{: RESULT = r; :}            ;                rules		::= rules:r1 rule:r2                 		{: RESULT = (Command) r2.addlast (r1); :}        	| rule:r                 		{: RESULT = r; :}            ;rule     	::= IF SEXP fexpresion:e {: fexp = e; :} EEXP postlist:l COLON						{: RESULT = l; :}		  	| BACKGROUND SEXP expresion:e EEXP postcond:s COLON						{: RESULT = (new Command ()).fbkg (s, e); :}       		| error                        {: error ("Fuzzy rule error"); :}             ;postlist	::= postelem:pc1 SCOLON postlist:pc2                		{: RESULT = (Command) pc1.addlast (pc2); :}       		| postelem:pc                		{: RESULT = pc; :}            ;postelem   	::= postcond:pc                		{: RESULT = (new Command ()).frule (pc, fexp); :}            ;postcond   	::= ID:na               			{: RESULT = check (na); :}	  	  	| ID:na IS ID:s						{: RESULT = (new VSymbol ()).vtuple (check (na), check (s)); :}	  	  	| ID:na IS set:s fuzzy:f                		{: tfexp = (new VSymbol ()).set (s, f);						   tsymbol.addlast (tfexp);                		   RESULT = (new VSymbol ()).vtuple (check (na), check (tfexp.name ())); :}	  	  	| ID:na IS number:n                		{: tfexp = (new VSymbol ()).number (n);						   tsymbol.addlast (tfexp);                		   RESULT = (new VSymbol ()).vtuple (check (na), check (tfexp.name ())); :}          	| error                        {: error ("Fuzzy rule postcondition error"); :}             ;/* ----------- Finite State Machine ------------ */states   	::= states:s1 state:s2                		{: RESULT = (Command) s2.addlast (s1); :}       		| state:s                 		{: RESULT = s; :}            ;state   	::= STATE ID:na BSTATE block:b						{: RESULT = (new Command ()).state (na, b); :}      		| error                        {: error ("State definition error"); :}             ;/* ----------- Real Numbers and Fuzzy Sets ------------ */ fuzzy   	::= BBEGIN frange:f BEND						{: RESULT = f; :}        	| error                        {: error ("Error on fuzzy set declaration"); :}             ;frange   	::= number:n SCOLON frange:f                		{: RESULT = (NList) f.addfirst (new NList (n)); :}       		| number:n                		{: RESULT = new NList (n); :}            ;number		::= DOUBLE:n						{: RESULT = n; :}		  	| MINUS DOUBLE:n									{: RESULT = new Double (-1.0 * n.doubleValue ()); :}		%prec UMINUS			;				/* -------------- Arithmetical, Relational, and Boolean Operators ------------ */expresion 	::= expresion:e1 PLUS expresion:e2						{: RESULT = (new Expresion ()).binary (Expresion.PLUS, e1, e2); :}			| expresion:e1 MINUS expresion:e2						{: RESULT = (new Expresion ()).binary (Expresion.MINUS, e1, e2); :}			| expresion:e1 TIMES expresion:e2						{: RESULT = (new Expresion ()).binary (Expresion.TIMES, e1, e2); :}		  	| expresion:e1 DIV expresion:e2						{: RESULT = (new Expresion ()).binary (Expresion.DIV, e1, e2); :}		  	| NOT expresion:e						{: RESULT = (new Expresion ()).unary (Expresion.NOT, e); :}			| expresion:e1 AND expresion:e2						{: RESULT = (new Expresion ()).binary (Expresion.AND, e1, e2); :}       		| expresion:e1 OR expresion:e2						{: RESULT = (new Expresion ()).binary (Expresion.OR, e1, e2); :}			| expresion:e1 EQUAL expresion:e2						{: RESULT = (new Expresion ()).binary (Expresion.EQUAL, e1, e2); :}			| expresion:e1 NE expresion:e2						{: RESULT = (new Expresion ()).binary (Expresion.NE, e1, e2); :}	   		| expresion:e1 GT expresion:e2						{: RESULT = (new Expresion ()).binary (Expresion.GT, e1, e2); :}	    	| expresion:e1 LT expresion:e2						{: RESULT = (new Expresion ()).binary (Expresion.LT, e1, e2); :}	       	| expresion:e1 GE expresion:e2						{: RESULT = (new Expresion ()).binary (Expresion.GE, e1, e2); :}      		| expresion:e1 LE expresion:e2						{: RESULT = (new Expresion ()).binary (Expresion.LE, e1, e2); :}    		| expresion:e1 IS expresion:e2						{: RESULT = (new Expresion ()).binary (Expresion.IS, e1, e2); :}        	| SEXP expresion:e EEXP                		{: RESULT = e; :}         	| ID:na                		{: RESULT = (new Expresion ()).terminal (check (na)); :}       		| number:n						{: RESULT = (new Expresion ()).terminal ((new VSymbol ()).number (n)); :}        	| function:f						{: RESULT = (new Expresion ()).terminal (f); :}        	| error                       	{: error ("Error in expresion"); :}    			;fexpresion	::= NOT fexpresion:f									{: RESULT = (new Expresion ()).unary (Expresion.NOT, f); :}           	| fexpresion:f1 AND fexpresion:f2						{: RESULT = (new Expresion ()).binary (Expresion.AND, f1, f2); :}         	| fexpresion:f1 OR fexpresion:f2						{: RESULT = (new Expresion ()).binary (Expresion.OR, f1, f2); :}		  	| fexpresion:f1 IS fexpresion:f2						{: RESULT = (new Expresion ()).binary (Expresion.IS, f1, f2); :}       		| SEXP fexpresion:f EEXP                		{: RESULT = f; :}        	| ID:na                		{: RESULT = (new Expresion ()).terminal (check (na)); :}			| set:s fuzzy:f                		{: tfexp = (new VSymbol ()).set (s, f);						   tsymbol.addlast (tfexp);                		   RESULT = (new Expresion ()).terminal (check (tfexp.name ())); :}    		| number:n						{: RESULT = (new Expresion ()).terminal ((new VSymbol ()).number (n)); :}         	| function:f						{: RESULT = (new Expresion ()).terminal (f); :}        	| error                        {: error ("Error in fuzzy expresion"); :}        		;